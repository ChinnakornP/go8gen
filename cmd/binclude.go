// Code generated by https://github.com/lu4p/binclude; DO NOT EDIT.

package cmd

import (
	"github.com/lu4p/binclude"
	"time"
)

var BinFS = &binclude.FileSystem{Files: binclude.Files{
	"..": {
		Filename: "..", Mode: 0o20000000777, ModTime: time.Unix(1609426634, 1609426634911161344), Compression: 0,
	},
	"../tmpl": {
		Filename: "tmpl", Mode: 0o20000000775, ModTime: time.Unix(1609423426, 1609423426931418066), Compression: 0,
	},
	"../tmpl/.env.tmpl": {
		Filename: ".env.tmpl", Mode: 0o664, ModTime: time.Unix(1609376884, 1609376884357966518), Compression: 0,
		Content: []byte("API_HOST=0.0.0.0\nAPI_PORT=3080\nAPI_READ_TIMEOUT:10\nAPI_READ_HEADER_TIMEOUT:10\nAPI_WRITE_TIMEOUT:10\nAPI_IDLE_TIMEOUT:10\nAPI_REQUEST_LOG=false\n\nDB_DRIVER=postgres\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=go8_user\nDB_PASS=go8_pass\nDB_NAME=go8_db\nDB_SSL_MODE=disable\n\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_NAME=1\nREDIS_USER=\nREDIS_PASS=\nREDIS_CACHE_TIME=5\n\nELASTICSEARCH_ADDRESS=http://localhost:9200\nELASTICSEARCH_USER=\nELASTICSEARCH_PASS=\n"),
	},
	"../tmpl/.gitignore.tmpl": {
		Filename: ".gitignore.tmpl", Mode: 0o664, ModTime: time.Unix(1609379252, 1609379252919568591), Compression: 0,
		Content: []byte(".idea\n.bin\n.data\nvendor\n.env\nsqlboiler.toml\n"),
	},
	"../tmpl/Dockerfile.tmpl": {
		Filename: "Dockerfile.tmpl", Mode: 0o664, ModTime: time.Unix(1609279553, 1609279553802000000), Compression: 0,
		Content: []byte("FROM alpine:latest\n\nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\n\nCOPY ./bin/app .\nCOPY ./bin/app/.env ."),
	},
	"../tmpl/README.md.tmpl": {
		Filename: "README.md.tmpl", Mode: 0o664, ModTime: time.Unix(1609379707, 1609379707574400228), Compression: 0,
		Content: []byte("# Introduction\n            .,*/(#####(/*,.                               .,*((###(/*.\n        .*(%%%%%%%%%%%%%%#/.                           .*#%%%%####%%%%#/.\n      ./#%%%%#(/,,...,,***.           .......          *#%%%#*.   ,(%%%#/.\n     .(#%%%#/.                    .*(#%%%%%%%##/,.     ,(%%%#*    ,(%%%#*.\n    .*#%%%#/.    ..........     .*#%%%%#(/((#%%%%(,     ,/#%%%#(/#%%%#(,\n    ./#%%%(*    ,#%%%%%%%%(*   .*#%%%#*     .*#%%%#,      *(%%%%%%%#(,.\n    ./#%%%#*    ,(((##%%%%(*   ,/%%%%/.      .(%%%#/   .*#%%%#(*/(#%%%#/,\n     ,#%%%#(.        ,#%%%(*   ,/%%%%/.      .(%%%#/  ,/%%%#/.    .*#%%%(,\n      *#%%%%(*.      ,#%%%(*   .*#%%%#*     ./#%%%#,  ,(%%%#*      .(%%%#*\n       ,(#%%%%%##(((##%%%%(*    .*#%%%%#(((##%%%%(,   .*#%%%##(///(#%%%#/.\n         .*/###%%%%%%%###(/,      .,/##%%%%%##(/,.      .*(##%%%%%%##(*,\n              .........                ......                .......\nA starter kit for Go API development. Inspired by [How I write HTTP services after eight years](https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html).\n\n However I wanted to use [chi router](https://github.com/go-chi/chi) which is more common in the\n  community, [sqlboiler](https://github.com/volatiletech/sqlboiler/) to solve database operations\n   and design towards more like [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html).\n\nThis kit tries to follow the [Standard Go Project Layout](https://github.com/golang-standards/project-layout) to make project structure familiar to a Go developer.\n\nIt is still in early stages and I do not consider it is completed until all integration tests are\n completed.\n\nIn short, this kit is a Go + Postgres + Chi Router + SqlBoiler starter kit for API development.\n\n# Motivation\n\nOn the topic of API development, there are two opposing camps between a framework (like\n [echo](https://github.com/labstack/echo), [gin](https://github.com/gin-gonic/gin),\n   [buffalo](http://gobuffalo.io/) and starting small and only add features you need. However\n   , starting small and adding features aren;t that straightforward. Also, you will want to\n    structure your project in such a way that there are clear separation of functionalities for\n     different files. This is the idea behind [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html). This way, it is easy to switch whichever library to another of your choice.\n\n   This project serves as a starting point. Further integrations such as elasticsearch, jobs,\n   and authentication are in separate branches.\n\n# Features\n\nThis kit is composed of standard Go library together with well known libraries to\n manage things like router, database query and migration support. Technically it supports\n [other databases](https://github.com/volatiletech/sqlboiler#supported-databases) as well.\n\n  - Router/Mux with [Chi Router](https://github.com/go-chi/chi)\n  - Database Operations with [Sqlboiler ORM](https://github.com/volatiletech/sqlboiler/)\n  - Database migration with [golang-migrate](https://github.com/golang-migrate/migrate/)\n  - Cache result with [Redis](https://redis.io) stored with [msgpack](https://msgpack.org) encoding\n  - Input [validation](https://github.com/go-playground/validator) that return multiple error\n   strings\n  - Scans and auto-generate [Swagger](https://github.com/swaggo/swag) docs using a declarative\n   comments format\n  - Request log that logs each user uniquely based on host address\n  - Cors\n  - Pagination through middleware\n\nIt has few dependencies and replacing one library to another is easy.\n\n\n# Quickstart\n\nYou need to [have a go binary](#appendix) and put into path as well as [git](#appendix). Optionally `docker` and `docker-compose` for easier start up.\n\n\nGet it\n\n    git clone https://github.com/gmhafiz/go8\n    cd go8\n\n\nThe minimum external dependency is the `golang-migrate` program. While technically you can run\n the schema in `database/migration` yourself, it is recommended to use the program instead. But\n  before doing this, create a directory where you can put your binaries and add this path to the\n   `PATH` environment variable.\n\n    mkdir -p ~/.local/bin\n\nTo add this newly created directory to `PATH` environment variable, add this line to `~/.profile\n` file\n\n    echo 'PATH=$PATH:$HOME/.local/bin' >> ~/.profile\n\nTo make your shell learn of the new path, reload your `~/.profile` file\n\n    source ~/.profile\n\n\nSo we first run a program that downloads all necessary tools for this kit to work. It also\n initializes various settings file including database credentials in `.env` and `sqlboiler.toml\n ` by asking you to set database datasourcename (DSN). This will make the `docker-compose` step\n  easy as it can read `.env` file created in this step.\n\n    go run cmd/init/main.go\n\n\nHave a database ready either by installing them yourself or the following command. the `docker\n-compose.yml` will use database credentials set in `.env` file which is initialized by the\n previous step. Optionally, you may redis as well.\n\n    docker-compose up -d postgres # or optionally redis\n    docker-compose up -d postgres redis\n\nOnce the database is up you may run the migration with,\n\n    go run cmd/extmigrate up\n\n\nRun the API with\n\n    go run cmd/go8/main.go\n\n\nYou will see the address the API is running at as well as all registered routes.\n\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:26 > starting at 0.0.0.0:3080 service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"GET\",\"path\":\"/api/v1/authors/\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"GET\",\"path\":\"/api/v1/books/\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"POST\",\"path\":\"/api/v1/books/\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"GET\",\"path\":\"/api/v1/books/{id}\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"PUT\",\"path\":\"/api/v1/books/{id}\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"DELETE\",\"path\":\"/api/v1/books/{id}\"} service=go8\n    2020-10-09T11:44:50+11:00 INF internal/server/rest/server.go:86 >  routes={\"method\":\"GET\",\"path\":\"/swagger\"} service=go8\n\nTo use, follow examples in the `examples/` folder\n\n    curl --location --request GET 'http://localhost:3080/api/v1/books'\n\n\n# Tools\n\nWhile the above quickstart is sufficient to start the API, some tools are included for easier\n task management.\n\nA. This project uses [Task](https://github.com/go-task/task) to handle various tasks such as\n migration, generation of swagger docs, build and run the app. It is essentially a [sh interpreter\n ](https://github.com/mvdan/sh). Only requirement is to download the binary and append to your `PATH` variable.\n\nInstall task runner binary bash script:\n\n    sudo ./scripts/install-task.sh\n\nThis installs `task` to `/usr/local/bin/task` so `sudo` is needed.\n\n`Task` tasks are defined inside `Taskfile.yml` file. A list of tasks available can be viewed with:\n\n    task -l   # or\n    task list\n\n\n## Migration\n\nMigration is a good step towards having a versioned database and makes publishing to a production\n server a safe process.\n\n### Create Migration\n\nUsing `Task`, creating a migration file is done by the following command. Name the file after\n `NAME=`.\n\n    task migrate-create NAME=create_a_tablename\n\n### Migrate up\n\nAfter you are satisfied with your `.sql` files, run the following command to migrate your database.\n\n    task migrate\n\nFurther `golang-migrate` commands are available in its [documentation (postgres)](https://github.com/golang-migrate/migrate/blob/master/database/postgres/TUTORIAL.md)\n\n## Database Generate Models and ORMs\n\nSqlBoiler treats your database as source of truth. It connects to your database, read its schema\n and generate appropriate models and query builder helpers written in Go. Utilizing a type-safe\n  query building allows compile-time error checks.\n\nGenerate ORM with:\n\n    task gen-orm\n\nGenerated files are as defined in the `sqlboiler.toml` file. This command needs to be run after\n every migration changes are done. Generated files are located in `internal/model`\n\n# Test\n\nInstall testify testing framework with\n\n    go get github.com/stretchr/testify\n\n# Run\n\n## Local\n\nConventionally, all apps are placed inside the `cmd` folder.\n\nUsing `Task`:\n\n    task run\n\nWithout `Task`\n\n    go run cmd/go8/main.go\n\n## Docker\n\nYou can build a docker image with the app with its config files. Docker needs to be installed\n beforehand.\n\n     task docker-build\n\nRun the following command to build a container from this image. `--net=host` tells the container\n to use local's network so that it can access local's database.\n\n    task docker-run\n\n\n# Swagger docs\n\nSwagger UI allows you to play with the API from a browser\n\n![swagger UI](assets/swagger.png)\n\nEdit `cmd/go8/go8.go` `main()` function host and BasePath\n\n    // @host localhost:3080\n    // @BasePath /api/v1\n\n\nGenerate with\n\n    task swagger\n\nAccess at\n\n    http://localhost:3080/swagger\n\nThe command `swag init` scans the whole directory and looks for [swagger's declarative comments](https://github.com/swaggo/swag#declarative-comments-format)\n format.\n\nCustom theme is obtained from [https://github.com/ostranme/swagger-ui-themes](https://github.com/ostranme/swagger-ui-themes)\n\n\n# Tooling\n\nVarious tooling are included within the `Task` runner\n\n  * `task fmt`\n    * Runs `go fmt ./...` to lint Go code\n    * `go fmt` is part of official Go toolchain that formats your code into an opinionated format.\n  * `task tidy`\n    * Runs `go mod tidy` to sync dependencies.\n  * `task vet`\n    * Quickly catches compile error.\n  * `task golint`\n    * Runs an opinionated code linter from https://golangci-lint.run/\n\n# Structure\n\nThis project mostly follows the structure documented at [Standard Go Project Layout](https://github.com/golang-standards/project-layout).\n\nIn addition, this project also tries to follow [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) where each functionality are separated into  different files.\n\n## Starting Point\nStarting point of project is at `cmd/go8/main.go`\n\n![main](assets/main.png)\n\nPurpose of this is to initialize all dependencies (logger, read .env, validation, database, redis) and\n passes it on to the `rest` package. After all domains are initialized, the rest server can be\n  started.\n\n## Domain\nLooking at the `internal/domain/books` folder:\n![book-domain](assets/domain-book.png)\n\n  * `handler.go` handles request coming in to perform input validation, calls usecase, and\n    formats the output.\n  * `routes.go` defines available routes for `books`.\n  * `usecase.go` receives request from handler, perform business logic, and call repository if\n   needed.\n  * `repository.go` handles database operations. Also may queries redis cache.\n  * `cache.go` performs redis queries.\n\n## Configurations\n![configs](assets/configs.png)\n\nAll environment variables are read into specific structs initialized in `configs/configs.go`.\n\n## Database\n\nMigrations are stored in `database/migrations` folder\n\n## Libraries\n\nInitialization of external libraries are located in `internal/library`\n\n![library](assets/library.png)\n\n# TODO\n\n - Complete HTTP integration test\n - use [xID](https://github.com/rs/xid) for table ID primary key\n - better control of json output formatting\n\n\n# Appendix\n\n## Dev Environment Installation\n\nFor ubuntu:\n\n    sudo apt update && sudo apt install git\n    wget https://golang.org/dl/go1.15.3.linux-amd64.tar.gz\n    sudo tar -C /usr/local -xzf go1.15.3.linux-amd64.tar.gz\n    export PATH=$PATH:/usr/local/go/bin\n    echo 'PATH=$PATH:/usr/local/go/bin' >> ~/.profile\n\n    sudo apt remove docker docker-engine docker.io containerd runc\n    sudo apt update\n    sudo apt install -y apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n    sudo apt update\n    sudo apt install -y docker-ce docker-ce-cli containerd.io\n    sudo usermod -aG docker ${USER}\n    newgrp docker\n    su - ${USER} # or logout and login\n\n    sudo curl -L \"https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n    sudo chmod +x /usr/local/bin/docker-compose\n"),
	},
	"../tmpl/Taskfile.tmpl": {
		Filename: "Taskfile.tmpl", Mode: 0o664, ModTime: time.Unix(1609381435, 1609381435113768001), Compression: 0,
		Content: []byte("version: '3'\n\ndotenv: ['.env']\n\ntasks:\n  list:\n    desc: Lists available commands\n    cmds:\n      - task -l\n\n  migrate-create:\n    desc: Creates .sql migration files (Up and Down). Set name by appending with'NAME={{name_of_file}}'\n    cmds:\n      - migrate create -ext sql -dir database/migrations -format unix \"{{ .NAME }}\"\n\n  migrate:\n    desc: Migrates UP the database\n    cmds:\n      - migrate -path database/migrations up\n\n  gen-orm:\n    desc: Reads your current database schema and creates models as well as orm.\n    cmds:\n      - sqlboiler --wipe --add-soft-deletes psql\n\n  run:\n    desc: Runs the app\n    cmds:\n      - go run cmd/go8/main.go\n\n  build:\n    desc: Creates a compiled binary and copy configuration files\n    cmds:\n      - go build -v -i cmd/go8/main.go\n      - mkdir -p build\n      - mv go8 build/\n      - mkdir build/config\n      - cp config/*.yml build/config\n\n  swagger:\n    desc: Generates Swagger page for API reference\n    cmds:\n      - swag init -g cmd/go8/main.go\n\n\n  docker-build:\n    desc: Builds a Docker image\n    cmds:\n      - docker build -t go8 -f docker/Dockerfile .\n\n  docker-run:\n    desc: Runs the app Docker image as a Docker container\n    cmds:\n      - docker run -p 3080:3080 --rm -it --net=host --name go8container go8\n\n  fmt:\n    desc: Lint code\n    cmds:\n      - go fmt ./...\n\n  tidy:\n    desc: Downloads dependencies and removes unused ones\n    cmds:\n      - go mod tidy\n\n  vet:\n    desc: Vets code\n    cmds:\n      - go vet ./...\n\n  golint:\n    desc: Uses golangci-lint\n    cmds:\n      - golangci-lint run"),
	},
	"../tmpl/cmd": {
		Filename: "cmd", Mode: 0o20000000775, ModTime: time.Unix(1609389323, 1609389323402225032), Compression: 0,
	},
	"../tmpl/cmd/main.tmpl": {
		Filename: "main.tmpl", Mode: 0o664, ModTime: time.Unix(1609389323, 1609389323402225032), Compression: 0,
		Content: []byte("package main\n\nimport (\n\t\"log\"\n\n\t\"{{ .ProjectName }}/configs\"\n\t\"{{ .ProjectName }}/internal/server\"\n)\n\nconst Version = \"v0.1.0\"\n\nfunc main() {\n\tcfg := configs.New()\n\n\ts := server.NewApp(cfg)\n\n\tif err := s.Run(cfg, Version); err != nil {\n\t\tlog.Fatalf(\"%s\", err.Error())\n\t}\n}\n"),
	},
	"../tmpl/configs": {
		Filename: "configs", Mode: 0o20000000775, ModTime: time.Unix(1609391609, 1609391609684762877), Compression: 0,
	},
	"../tmpl/configs/api.go.tmpl": {
		Filename: "api.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609381891, 1609381891476522772), Compression: 0,
		Content: []byte("package configs\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Api struct {\n\tHost              string\n\tPort              string\n\tReadTimeout       time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout      time.Duration\n\tIdleTimeout       time.Duration\n\tRequestLog        bool\n}\n\nfunc API() *Api {\n\tapiReadTimeout, _ := strconv.Atoi(os.Getenv(\"API_READ_TIMEOUT\"))\n\tapiReadHeaderTimeout, _ := strconv.Atoi(os.Getenv(\"API_READ_HEADER_TIMEOUT\"))\n\tapiWriteTimeout, _ := strconv.Atoi(os.Getenv(\"API_WRITE_TIMEOUT\"))\n\tapiIdleTimeout, _ := strconv.Atoi(os.Getenv(\"API_IDLE_TIMEOUT\"))\n\trequestLog, _ := strconv.ParseBool(os.Getenv(\"API_REQUEST_LOG\"))\n\n\treturn &Api{\n\t\tHost:              os.Getenv(\"API_HOST\"),\n\t\tPort:              os.Getenv(\"API_PORT\"),\n\t\tReadTimeout:       time.Duration(apiReadTimeout),\n\t\tReadHeaderTimeout: time.Duration(apiReadHeaderTimeout),\n\t\tWriteTimeout:      time.Duration(apiWriteTimeout),\n\t\tIdleTimeout:       time.Duration(apiIdleTimeout),\n\t\tRequestLog:        requestLog,\n\t}\n}\n"),
	},
	"../tmpl/configs/cache.go.tmpl": {
		Filename: "cache.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609381955, 1609381955364354308), Compression: 0,
		Content: []byte("package configs\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Cache struct {\n\tHost      string\n\tPort      string\n\tName      int\n\tUser      string\n\tPass      string\n\tCacheTime int\n}\n\nfunc NewCache() *Cache {\n\tname, err := strconv.Atoi(os.Getenv(\"REDIS_NAME\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tcacheTime, err := strconv.Atoi(os.Getenv(\"REDIS_CACHE_TIME\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn &Cache{\n\t\tHost:      os.Getenv(\"REDIS_HOST\"),\n\t\tPort:      os.Getenv(\"REDIS_PORT\"),\n\t\tName:      name,\n\t\tUser:      os.Getenv(\"REDIS_USER\"),\n\t\tPass:      os.Getenv(\"REDIS_PASS\"),\n\t\tCacheTime: cacheTime,\n\t}\n}\n"),
	},
	"../tmpl/configs/configs.go.tmpl": {
		Filename: "configs.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609376129, 1609376129735818083), Compression: 0,
		Content: []byte("package configs\n\nimport (\n    \"log\"\n\n    \"github.com/joho/godotenv\"\n)\n\ntype Configs struct {\n    Api           *Api\n    Database      *Database\n    Cache         *Cache\n    Elasticsearch *Elasticsearch\n}\n\nfunc New() *Configs {\n    err := godotenv.Load()\n        if err != nil {\n        log.Fatal(err)\n    }\n\n    api := API()\n    dataStore := DataStore()\n    cache := NewCache()\n    es := ElasticSearch()\n\n    return &Configs {\n        Api:           api,\n        Database:      dataStore,\n        Cache:         cache,\n        Elasticsearch: es,\n    }\n}\n"),
	},
	"../tmpl/configs/database.go.tmpl": {
		Filename: "database.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609382004, 1609382004192226209), Compression: 0,
		Content: []byte("package configs\n\nimport \"os\"\n\ntype Database struct {\n\tDriver  string\n\tHost    string\n\tPort    string\n\tName    string\n\tUser    string\n\tPass    string\n\tSslMode string\n}\n\nfunc DataStore() *Database {\n\treturn &Database{\n\t\tDriver:  os.Getenv(\"DB_DRIVER\"),\n\t\tHost:    os.Getenv(\"DB_HOST\"),\n\t\tPort:    os.Getenv(\"DB_PORT\"),\n\t\tName:    os.Getenv(\"DB_NAME\"),\n\t\tUser:    os.Getenv(\"DB_USER\"),\n\t\tPass:    os.Getenv(\"DB_PASS\"),\n\t\tSslMode: os.Getenv(\"DB_SSL_MODE\"),\n\t}\n}\n"),
	},
	"../tmpl/configs/elasticsearch.go.tmpl": {
		Filename: "elasticsearch.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609382017, 1609382017408191626), Compression: 0,
		Content: []byte("package configs\n\nimport \"os\"\n\ntype Elasticsearch struct {\n\tAddress  string\n\tUser     string\n\tPassword string\n}\n\nfunc ElasticSearch() *Elasticsearch {\n\treturn &Elasticsearch{\n\t\tAddress:  os.Getenv(\"ELASTICSEARCH_ADDRESS\"),\n\t\tUser:     os.Getenv(\"ELASTICSEARCH_USER\"),\n\t\tPassword: os.Getenv(\"ELASTICSEARCH_PASS\"),\n\t}\n}\n"),
	},
	"../tmpl/docker-compose.yml.tmpl": {
		Filename: "docker-compose.yml.tmpl", Mode: 0o664, ModTime: time.Unix(1609279456, 1609279456454000000), Compression: 0,
		Content: []byte("version: '3.4'\n\nservices:\n\n  server:\n    image: go8\n    container_name: \"go8container\"\n    build: ./\n    command: ./app\n    ports:\n      - ${API_PORT}:${API_PORT}\n    depends_on:\n      - postgres\n    environment:\n      - WAIT_HOSTS: postgres:${DB_PORT}\n\n  postgres:\n    image: \"postgres:13\"\n    restart: always\n    container_name: \"go8_postgres\"\n    environment:\n      - POSTGRES_USER=${DB_USER}\n      - POSTGRES_PASSWORD=${DB_PASS}\n      - POSTGRES_DB=${DB_NAME}\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres13go8db:/var/lib/postgresql/data\n\nvolumes:\n  postgres13go8db:"),
	},
	"../tmpl/domain": {
		Filename: "domain", Mode: 0o20000000775, ModTime: time.Unix(1609412836, 1609412836390169173), Compression: 0,
	},
	"../tmpl/domain/http": {
		Filename: "http", Mode: 0o20000000775, ModTime: time.Unix(1609413165, 1609413165217212349), Compression: 0,
	},
	"../tmpl/domain/http/handler.go.tmpl": {
		Filename: "handler.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609413165, 1609413165217212349), Compression: 0,
		Content: []byte("package http\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-chi/render\"\n\t\"github.com/go-playground/validator/v10\"\n\t\"github.com/volatiletech/null/v8\"\n\n\t\"{{ .ProjectName }}/internal/domain/{{ .DomainLowerCase }}\"\n\t\"{{ .ProjectName }}/internal/model\"\n\t\"{{ .ProjectName }}/internal/resource\"\n)\n\ntype Handler struct {\n\tuseCase  {{ .DomainLowerCase }}.UseCase\n\tvalidate *validator.Validate\n}\n\nfunc NewHandler(useCase {{ .DomainLowerCase }}.UseCase) *Handler {\n\treturn &Handler{\n\t\tuseCase:  useCase,\n\t\tvalidate: validator.New(),\n\t}\n}\n\ntype {{ .Domain }}Request struct {\n\tTitle         string `json:\"title\" validate:\"required\"`\n\tPublishedDate string `json:\"published_date\" validate:\"required\"`\n\tImageURL      string `json:\"image_url\" validate:\"url\"`\n\tDescription   string `json:\"description\" validate:\"required\"`\n}\n\ntype {{ .Domain }}Resource struct {\n\t{{ .Domain }}ID      int64       `json:\"{{ .DomainLowerCase }}_id\" deepcopier:\"field:{{ .DomainLowerCase }}_id\" db:\"id\"`\n\tTitle         string      `json:\"title\" deepcopier:\"field:title\" db:\"title\"`\n\tPublishedDate time.Time   `json:\"published_date\" deepcopier:\"field:force\" db:\"published_date\"`\n\tImageURL      null.String `json:\"image_url\" deepcopier:\"field:image_url\" db:\"image_url\"`\n\tDescription   null.String `json:\"description\" deepcopier:\"field:description\"`\n}\n\n\nfunc (h *Handler) Create(w http.ResponseWriter, r *http.Request) {\n\tvar {{ .DomainLowerCase }}Request resource.{{ .Domain }}Request\n\terr := json.NewDecoder(r.Body).Decode(&{{ .DomainLowerCase }}Request)\n\tif err != nil {\n\t\trender.Status(r, http.StatusBadRequest)\n\t\trender.JSON(w, r, nil)\n\t\treturn\n\t}\n\n\terr = h.validate.Struct({{ .DomainLowerCase }}Request)\n\tif err != nil {\n\t\t// this check is only needed when your code could produce\n\t\t// an invalid value for validation such as interface with nil\n\t\t// value most including myself do not usually have code like this.\n\t\tif _, ok := err.(*validator.InvalidValidationError); ok {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tvar errs []string\n\t\tfor _, err := range err.(validator.ValidationErrors) {\n\t\t\terrs = append(errs, fmt.Sprintf(\"%s is %s\", err.StructNamespace(), err.Tag()))\n\t\t}\n\t\trender.Status(r, http.StatusBadRequest)\n\t\trender.JSON(w, r, map[string][]string{\"errors\": errs})\n\t\treturn\n\t}\n\n\ta := &model.{{ .Domain }}{\n\t\tTitle:         \"\",\n\t\tPublishedDate: time.Time{},\n\t\tDescription:   null.String{},\n\t}\n\tbk, err := h.useCase.Create(context.Background(), a)\n\tif err != nil {\n\t\trender.Status(r, http.StatusInternalServerError)\n\t\trender.JSON(w, r, nil)\n\t\treturn\n\t}\n\n\trender.Status(r, http.StatusCreated)\n\trender.JSON(w, r, bk)\n}\n\nfunc (h *Handler) All(w http.ResponseWriter, r *http.Request) {\n\tresp, err := h.useCase.All(r.Context())\n\tif err != nil {\n\t\trender.Status(r, http.StatusInternalServerError)\n\t\trender.JSON(w, r, err.Error())\n\t\treturn\n\t}\n\n\tlist, err := resource.{{ .Domain }}s(resp)\n\tif err != nil {\n\t\trender.Status(r, http.StatusInternalServerError)\n\t\trender.JSON(w, r, err.Error())\n\t\treturn\n\t}\n\n\trender.JSON(w, r, list)\n}\n"),
	},
	"../tmpl/domain/http/register.go.tmpl": {
		Filename: "register.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609399150, 1609399150201284406), Compression: 0,
		Content: []byte("package http\n\nimport (\n\t\"github.com/go-chi/chi\"\n\n\t\"{{ .ProjectName }}/internal/domain/{{ .DomainLowerCase }}\"\n\t\"{{ .ProjectName }}/internal/middleware\"\n)\n\nfunc RegisterHTTPEndPoints(router *chi.Mux, uc {{ .DomainLowerCase }}.UseCase) {\n\th := NewHandler(uc)\n\n\trouter.Route(\"/api/v1/{{ .DomainLowerCase }}s\", func(router chi.Router) {\n\t\trouter.With(middleware.Paginate).Get(\"/\", h.All)\n\t\trouter.Post(\"/\", h.Create)\n\t})\n}\n"),
	},
	"../tmpl/domain/repository": {
		Filename: "repository", Mode: 0o20000000775, ModTime: time.Unix(1609396749, 1609396749843476767), Compression: 0,
	},
	"../tmpl/domain/repository.go.tmpl": {
		Filename: "repository.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609412836, 1609412836390169173), Compression: 0,
		Content: []byte("package {{ .DomainLowerCase }}\n\nimport (\n\t\"context\"\n\n\t\"{{ .ProjectName }}/internal/model\"\n\t\"{{ .ProjectName }}/internal/resource\"\n)\n\ntype Repository interface {\n\tCreate(ctx context.Context, {{ .Domain }} *model.{{ .Domain }}) (*model.{{ .Domain }}, error)\n\tAll(ctx context.Context) ([]resource.{{ .Domain }}DB, error)\n\tRead(ctx context.Context) (int64, error)\n\tUpdate(ctx context.Context) (*model.{{ .Domain }}, error)\n\tDelete(ctx context.Context) (*model.{{ .Domain }}, error)\n\tClose()\n\tDrop() error\n\tUp() error\n}"),
	},
	"../tmpl/domain/repository/postgres": {
		Filename: "postgres", Mode: 0o20000000775, ModTime: time.Unix(1609413165, 1609413165205212384), Compression: 0,
	},
	"../tmpl/domain/repository/postgres/postgres.go.tmpl": {
		Filename: "postgres.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609413165, 1609413165201212396), Compression: 0,
		Content: []byte("package postgres\n\nimport (\n\t\"context\"\n\n\t\"github.com/jmoiron/sqlx\"\n\n\t\"{{ .ProjectName }}/internal/domain/{{ .DomainLowerCase }}\"\n\t\"{{ .ProjectName }}/internal/model\"\n\t\"{{ .ProjectName }}/internal/resource\"\n)\n\ntype repository struct {\n\tdb *sqlx.DB\n}\n\nfunc New{{ .Domain }}Repository(db *sqlx.DB) {{ .DomainLowerCase }}.Repository {\n\treturn &repository{db: db}\n}\n\nfunc (r *repository) All(ctx context.Context) ([]resource.{{ .Domain }}DB, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (r *repository) Read(ctx context.Context) (int64, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (r *repository) Update(ctx context.Context) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (r *repository) Delete(ctx context.Context) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (r *repository) Create(ctx context.Context, {{ .DomainLowerCase }} *model.{{ .Domain }}) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}\n\n// Close attaches the provider and close the connection\nfunc (r *repository) Close() {\n\tr.db.Close()\n}\n\n// Up attaches the provider and create the table\nfunc (r *repository) Up() error {\n\tctx := context.Background()\n\n\tquery := \"CREATE table {{ .DomainLowerCase }}s({{ .DomainLowerCase }}_id bigserial, title varchar(255) not null, published_date timestamp with time zone not null, image_url varchar(255), description text not null, created_at timestamp with time zone default current_timestamp, updated_at timestamp with time zone default current_timestamp, deleted_at timestamp with time zone, primary key ({{ .DomainLowerCase }}_id))\"\n\tstmt, err := r.db.PrepareContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.ExecContext(ctx)\n\treturn err\n}\n\n// Drop attaches the provider and drop the table\nfunc (r *repository) Drop() error {\n\tctx := context.Background()\n\n\tquery := \"DROP TABLE IF EXISTS {{ .DomainLowerCase }}s cascade\"\n\tstmt, err := r.db.PrepareContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.ExecContext(ctx)\n\treturn err\n}\n"),
	},
	"../tmpl/domain/usecase": {
		Filename: "usecase", Mode: 0o20000000775, ModTime: time.Unix(1609412988, 1609412988389724554), Compression: 0,
	},
	"../tmpl/domain/usecase.go.tmpl": {
		Filename: "usecase.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609412836, 1609412836378169209), Compression: 0,
		Content: []byte("package {{ .DomainLowerCase }}\n\nimport (\n\t\"context\"\n\n\t\"{{ .ProjectName }}/internal/model\"\n\t\"{{ .ProjectName }}/internal/resource\"\n)\n\ntype UseCase interface {\n\tCreate(ctx context.Context, {{ .Domain }} *model.{{ .Domain }}) (*model.{{ .Domain }}, error)\n\tAll(ctx context.Context) ([]resource.{{ .Domain }}DB, error)\n\tRead(ctx context.Context) (int64, error)\n\tUpdate(ctx context.Context) (*model.{{ .Domain }}, error)\n\tDelete(ctx context.Context) (*model.{{ .Domain }}, error)\n}"),
	},
	"../tmpl/domain/usecase/usecase.go.tmpl": {
		Filename: "usecase.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609412988, 1609412988389724554), Compression: 0,
		Content: []byte("package usecase\n\nimport (\n\t\"context\"\n\n\t\"{{ .ProjectName }}/internal/domain/{{ .DomainLowerCase }}\"\n\t\"{{ .ProjectName }}/internal/model\"\n\t\"{{ .ProjectName }}/internal/resource\"\n)\n\ntype {{ .Domain }}UseCase struct {\n\t{{ .DomainLowerCase }}Repo {{ .DomainLowerCase }}.Repository\n}\n\nfunc New{{ .Domain }}UseCase({{ .DomainLowerCase }}Repo {{ .DomainLowerCase }}.Repository) *{{ .Domain }}UseCase {\n\treturn &{{ .Domain }}UseCase{\n\t\t{{ .DomainLowerCase }}Repo: {{ .DomainLowerCase }}Repo,\n\t}\n}\n\nfunc (u *{{ .Domain }}UseCase) Create(ctx context.Context, {{ .Domain }} *model.{{ .Domain }}) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (u *{{ .Domain }}UseCase) All(ctx context.Context) ([]resource.{{ .Domain }}DB, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (u *{{ .Domain }}UseCase) Read(ctx context.Context) (int64, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (u *{{ .Domain }}UseCase) Update(ctx context.Context) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}\n\nfunc (u *{{ .Domain }}UseCase) Delete(ctx context.Context) (*model.{{ .Domain }}, error) {\n\tpanic(\"implement me\")\n}"),
	},
	"../tmpl/health": {
		Filename: "health", Mode: 0o20000000775, ModTime: time.Unix(1609391794, 1609391794364357634), Compression: 0,
	},
	"../tmpl/health/http": {
		Filename: "http", Mode: 0o20000000775, ModTime: time.Unix(1609393170, 1609393170337112574), Compression: 0,
	},
	"../tmpl/health/http/handler.go.tmpl": {
		Filename: "handler.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609393170, 1609393170333112586), Compression: 0,
		Content: []byte("package http\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/render\"\n\n\t\"{{ .ProjectName }}/internal/domain/health\"\n)\n\ntype Handler struct {\n\tuseCase health.UseCase\n}\n\nfunc NewHandler(useCase health.UseCase) *Handler {\n\treturn &Handler{\n\t\tuseCase: useCase,\n\t}\n}\n\nfunc (h *Handler) Liveness(w http.ResponseWriter, r *http.Request) {\n\trender.Status(r, http.StatusOK)\n}\n\nfunc (h *Handler) Readiness(w http.ResponseWriter, r *http.Request) {\n\terr := h.useCase.Readiness()\n\tif err != nil {\n\t\trender.Status(r, http.StatusInternalServerError)\n\t\trender.JSON(w, r, nil)\n\t}\n\trender.Status(r, http.StatusOK)\n}"),
	},
	"../tmpl/health/http/register.go.tmpl": {
		Filename: "register.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609391609, 1609391609896762419), Compression: 0,
		Content: []byte("package http\n\nimport (\n\t\"github.com/go-chi/chi\"\n\n\t\"{{ .ProjectName }}/internal/domain/health\"\n)\n\nfunc RegisterHTTPEndPoints(router *chi.Mux, uc health.UseCase) {\n\th := NewHandler(uc)\n\n\trouter.Route(\"/health\", func(router chi.Router) {\n\t\trouter.Get(\"/liveness\", h.Liveness)\n\t\trouter.Get(\"/readiness\", h.Readiness)\n\t})\n}"),
	},
	"../tmpl/health/postgres": {
		Filename: "postgres", Mode: 0o20000000775, ModTime: time.Unix(1609391736, 1609391736520485900), Compression: 0,
	},
	"../tmpl/health/postgres/postgres.go.tmpl": {
		Filename: "postgres.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609391731, 1609391731152497747), Compression: 0,
		Content: []byte("package postgres\n\nimport (\n\t\"github.com/jmoiron/sqlx\"\n)\n\ntype repository struct {\n\tdb *sqlx.DB\n}\n\nfunc NewHealthRepository(db *sqlx.DB) *repository {\n\treturn &repository{\n\t\tdb: db,\n\t}\n}\n\nfunc (r *repository) Readiness() error {\n\treturn r.db.Ping()\n}"),
	},
	"../tmpl/health/repository.go.tmpl": {
		Filename: "repository.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609391781, 1609391781540386164), Compression: 0,
		Content: []byte("package health\n\ntype Repository interface {\n\tReadiness() error\n}\n"),
	},
	"../tmpl/health/usecase": {
		Filename: "usecase", Mode: 0o20000000775, ModTime: time.Unix(1609393170, 1609393170345112550), Compression: 0,
	},
	"../tmpl/health/usecase.go.tmpl": {
		Filename: "usecase.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609391794, 1609391794360357642), Compression: 0,
		Content: []byte("package health\n\ntype UseCase interface {\n\tReadiness() error\n}"),
	},
	"../tmpl/health/usecase/usecase.go.tmpl": {
		Filename: "usecase.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609393170, 1609393170341112562), Compression: 0,
		Content: []byte("package usecase\n\nimport \"{{ .ProjectName }}/internal/domain/health\"\n\ntype Health struct {\n\thealthRepo health.Repository\n}\n\nfunc NewHealthUseCase(health health.Repository) *Health {\n\treturn &Health {\n\t\thealthRepo: health,\n\t}\n}\n\nfunc (u *Health) Readiness() error {\n\treturn u.healthRepo.Readiness()\n}"),
	},
	"../tmpl/middleware": {
		Filename: "middleware", Mode: 0o20000000775, ModTime: time.Unix(1609392796, 1609392796490036892), Compression: 0,
	},
	"../tmpl/middleware/cors.go.tmpl": {
		Filename: "cors.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609392796, 1609392796486036901), Compression: 0,
		Content: []byte("package middleware\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/cors\"\n)\n\nfunc Cors(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tcors.Handler(cors.Options{\n\t\t\t// AllowedOrigins: []string{\"https://foo.com\"}, // Use this to allow specific origin hosts\n\t\t\tAllowedOrigins: []string{\"*\"},\n\t\t\t// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },\n\t\t\tAllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\t\tAllowedHeaders:   []string{\"Accept\", \"Authorization\", \"Content-Type\", \"X-CSRF-Token\"},\n\t\t\tExposedHeaders:   []string{\"Link\"},\n\t\t\tAllowCredentials: false,\n\t\t\tMaxAge:           300, // Maximum value not ignored by any of major browsers\n\t\t})\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n"),
	},
	"../tmpl/middleware/paginate.go.tmpl": {
		Filename: "paginate.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609391922, 1609391922036071004), Compression: 0,
		Content: []byte("package middleware\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi\"\n)\n\nconst (\n\tpaginationKey string = \"pagination\"\n\tidKey         string = \"id\"\n)\n\ntype Pagination struct {\n\tTotal int `json:\"total\"`\n\tPage  int `json:\"page\"`\n\tSize  int `json:\"size\"`\n}\n\ntype ID struct {\n\tId int64 `json:\"id\"`\n}\n\nfunc Paginate(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tvar pagination Pagination\n\n\t\tif from := r.URL.Query().Get(\"page\"); from != \"\" {\n\t\t\tp, err := strconv.Atoi(from)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n\t\t\t}\n\t\t\tpagination.Page = p\n\t\t} else {\n\t\t\tpagination.Page = 1\n\t\t}\n\n\t\tif limit := r.URL.Query().Get(\"size\"); limit != \"\" {\n\t\t\tl, err := strconv.Atoi(limit)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n\t\t\t}\n\t\t\tpagination.Size = l\n\t\t} else {\n\t\t\tpagination.Size = 10\n\t\t}\n\n\t\tctx := context.WithValue(r.Context(), paginationKey, pagination)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\nfunc IDParam(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tbookID := chi.URLParam(r, \"id\")\n\t\tidInt64, _ := strconv.ParseInt(bookID, 10, 64)\n\n\t\tctx := context.WithValue(r.Context(), idKey, idInt64)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n"),
	},
	"../tmpl/model": {
		Filename: "model", Mode: 0o20000000775, ModTime: time.Unix(1609400532, 1609400532174378994), Compression: 0,
	},
	"../tmpl/model/model.go.tmpl": {
		Filename: "model.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609400532, 1609400532174378994), Compression: 0,
		Content: []byte("package model\n\nimport (\n\t\"time\"\n\n\t\"github.com/volatiletech/null/v8\"\n)\n\n// {{ .Domain }} is an object representing the database table.\ntype {{ .Domain }} struct {\n\t{{ .Domain }}ID        int64       `boil:\"{{ .DomainLowerCase }}_id\" json:\"{{ .DomainLowerCase }}_id\" toml:\"{{ .DomainLowerCase }}_id\" yaml:\"{{ .DomainLowerCase }}_id\"`\n\tTitle         string      `boil:\"title\" json:\"title\" toml:\"title\" yaml:\"title\"`\n\tPublishedDate time.Time   `boil:\"published_date\" json:\"published_date\" toml:\"published_date\" yaml:\"published_date\"`\n\tImageURL      null.String `boil:\"image_url\" json:\"image_url,omitempty\" toml:\"image_url\" yaml:\"image_url,omitempty\"`\n\tDescription   null.String `boil:\"description\" json:\"description,omitempty\" toml:\"description\" yaml:\"description,omitempty\"`\n\tCreatedAt     null.Time   `boil:\"created_at\" json:\"created_at,omitempty\" toml:\"created_at\" yaml:\"created_at,omitempty\"`\n\tUpdatedAt     null.Time   `boil:\"updated_at\" json:\"updated_at,omitempty\" toml:\"updated_at\" yaml:\"updated_at,omitempty\"`\n\tDeletedAt     null.Time   `boil:\"deleted_at\" json:\"deleted_at,omitempty\" toml:\"deleted_at\" yaml:\"deleted_at,omitempty\"`\n}\n\nvar {{ .Domain }}Columns = struct {\n\t{{ .Domain }}ID        string\n\tTitle         string\n\tPublishedDate string\n\tImageURL      string\n\tDescription   string\n\tCreatedAt     string\n\tUpdatedAt     string\n\tDeletedAt     string\n}{\n\t{{ .Domain }}ID:        \"{{ .DomainLowerCase }}_id\",\n\tTitle:         \"title\",\n\tPublishedDate: \"published_date\",\n\tImageURL:      \"image_url\",\n\tDescription:   \"description\",\n\tCreatedAt:     \"created_at\",\n\tUpdatedAt:     \"updated_at\",\n\tDeletedAt:     \"deleted_at\",\n}"),
	},
	"../tmpl/resource": {
		Filename: "resource", Mode: 0o20000000775, ModTime: time.Unix(1609400772, 1609400772749814239), Compression: 0,
	},
	"../tmpl/resource/resource.go.tmpl": {
		Filename: "resource.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609400756, 1609400756077853590), Compression: 0,
		Content: []byte("package resource\n\nimport (\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/volatiletech/null/v8\"\n)\n\ntype {{ .Domain }}Request struct {\n\tTitle         string `json:\"title\" validate:\"required\"`\n\tPublishedDate string `json:\"published_date\" validate:\"required\"`\n\tImageURL      string `json:\"image_url\" validate:\"url\"`\n\tDescription   string `json:\"description\" validate:\"required\"`\n}\n\ntype {{ .Domain }}Resource struct {\n\t{{ .Domain }}ID        int64       `json:\"{{ .DomainLowerCase }}_id\" deepcopier:\"field:{{ .DomainLowerCase }}_id\" db:\"id\"`\n\tTitle         string      `json:\"title\" deepcopier:\"field:title\" db:\"title\"`\n\tPublishedDate time.Time   `json:\"published_date\" deepcopier:\"field:force\" db:\"published_date\"`\n\tImageURL      null.String `json:\"image_url\" deepcopier:\"field:image_url\" db:\"image_url\"`\n\tDescription   null.String `json:\"description\" deepcopier:\"field:description\"`\n}\n\ntype {{ .Domain }}DB struct {\n\t{{ .Domain }}ID        int64       `db:\"{{ .DomainLowerCase }}_id\"`\n\tTitle         string      `db:\"title\"`\n\tPublishedDate time.Time   `db:\"published_date\"`\n\tImageURL      null.String `db:\"image_url\"`\n\tDescription   null.String `db:\"description\"`\n\tCreatedAt     null.Time   `db:\"created_at\"`\n\tUpdatedAt     null.Time   `db:\"updated_at\"`\n\tDeletedAt     null.Time   `db:\"deleted_at\"`\n}\n\nfunc {{ .Domain }}({{ .DomainLowerCase }} {{ .Domain }}DB) ({{ .Domain }}Resource, error) {\n\tvar resource {{ .Domain }}Resource\n\n\terr := copier.Copy(&resource, &{{ .DomainLowerCase }})\n\tif err != nil {\n\t\treturn resource, err\n\t}\n\n\treturn resource, nil\n}\n\nfunc {{ .Domain }}s({{ .DomainLowerCase }}s []{{ .Domain }}DB) (interface{}, error) {\n\tvar resource {{ .Domain }}Resource\n\n\trt := reflect.TypeOf({{ .DomainLowerCase }}s)\n\tif rt.Kind() == reflect.Slice {\n\t\tvar resources []{{ .Domain }}Resource\n\t\tfor _, {{ .DomainLowerCase }} := range {{ .DomainLowerCase }}s {\n\t\t\tres, _ := {{ .Domain }}({{ .DomainLowerCase }})\n\t\t\tresources = append(resources, res)\n\t\t}\n\t\treturn resources, nil\n\t}\n\n\terr := copier.Copy(&resource, {{ .DomainLowerCase }}s)\n\tif err != nil {\n\t\treturn resource, err\n\t}\n\n\treturn resource, nil\n}"),
	},
	"../tmpl/scripts": {
		Filename: "scripts", Mode: 0o20000000775, ModTime: time.Unix(1609392168, 1609392168627506975), Compression: 0,
	},
	"../tmpl/scripts/install-task.sh": {
		Filename: "install-task.sh", Mode: 0o664, ModTime: time.Unix(1609392168, 1609392168627506975), Compression: 0,
		Content: []byte("#!/usr/bin/env bash\n\n# bool function to test if the user is root or not\nis_user_root () { [ ${EUID:-$(id -u)} -eq 0 ]; }\n\nTASKPATH=$(which task)\nif [ -z \"$TASKPATH\" ]\nthen\n  if is_user_root;\n  then\n    curl -sL https://taskfile.dev/install.sh | sh\n    sudo mv bin/task /usr/local/bin\n    echo \"task binary added to \\$PATH\"\n    rm -R bin\n  else\n    echo \"you need to be a sudo to add the binary to \\$PATH\"\n  fi\nelse\n  echo \"Task has already been installed\"\nfi\n"),
	},
	"../tmpl/server": {
		Filename: "server", Mode: 0o20000000775, ModTime: time.Unix(1609404369, 1609404369129146017), Compression: 0,
	},
	"../tmpl/server/server.go.tmpl": {
		Filename: "server.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609404369, 1609404369129146017), Compression: 0,
		Content: []byte("package server\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi\"\n\tchiMiddleware \"github.com/go-chi/chi/middleware\"\n\n\t\"{{ .ProjectName }}/configs\"\n\t\"{{ .ProjectName }}/internal/domain/health\"\n\thealthHTTP \"{{ .ProjectName }}/internal/domain/health/handler/http\"\n\t// inject:import\n\t\"{{ .ProjectName }}/internal/domain/health/repository/postgres\"\n\t\"{{ .ProjectName }}/internal/domain/health/usecase\"\n\t\"{{ .ProjectName }}/internal/middleware\"\n\t\"{{ .ProjectName }}/third_party/database\"\n)\n\ntype App struct {\n\thttpServer *http.Server\n\thealthUC health.UseCase\n\t//inject:app\n}\n\nfunc NewApp(cfg *configs.Configs) *App {\n\tdb := database.NewSqlx(cfg)\n\n\treturn &App{\n\t\thealthUC: usecase.NewHealthUseCase(postgres.NewHealthRepository(db)),\n\t\t// inject:usecase\n\t}\n}\n\nfunc (a *App) Run(cfg *configs.Configs, version string) error {\n\trouter := chi.NewRouter()\n\trouter.Use(middleware.Cors)\n\trouter.Use(chiMiddleware.Logger)\n\trouter.Use(chiMiddleware.Recoverer)\n\n\thealthHTTP.RegisterHTTPEndPoints(router, a.healthUC)\n\t// inject:handler\n\n\ta.httpServer = &http.Server{\n\t\tAddr:           \":\" + cfg.Api.Port,\n\t\tHandler:        router,\n\t\tReadTimeout:    cfg.Api.ReadTimeout * time.Second,\n\t\tWriteTimeout:   cfg.Api.WriteTimeout * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\tlog.Printf(\"API version: %s\\n\", version)\n\t\tlog.Printf(\"serving at %s:%s\\n\", cfg.Api.Host, cfg.Api.Port)\n\t\tprintAllRegisteredRoutes(router)\n\t\terr := a.httpServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to listen and serve: %+v\", err)\n\t\t}\n\t}()\n\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, os.Interrupt, os.Interrupt)\n\n\t<-quit\n\n\tctx, shutdown := context.WithTimeout(context.Background(), cfg.Api.IdleTimeout*time.Second)\n\tdefer shutdown()\n\n\treturn a.httpServer.Shutdown(ctx)\n}\n\nfunc printAllRegisteredRoutes(router *chi.Mux) {\n\twalkFunc := func(method string, path string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n\t\tlog.Printf(\"path: %s method: %s \", path, method)\n\t\treturn nil\n\t}\n\tif err := chi.Walk(router, walkFunc); err != nil {\n\t\tlog.Print(err)\n\t}\n}\n"),
	},
	"../tmpl/sqlboiler.toml.tmpl": {
		Filename: "sqlboiler.toml.tmpl", Mode: 0o664, ModTime: time.Unix(1609379252, 1609379252927568571), Compression: 0,
		Content: []byte("output   = \"internal/models\"\nwipe     = true\nno-tests = true\ndebug    = false\n\n[psql]\ndbname = \"\"\nhost   = \"localhost\"\nport   = 5432\nuser   = \"\"\npass   = \"\"\nsslmode = \"disable\"\nschema = \"public\"\nblacklist = [\"migrations\", \"schema_migrations\"]\n"),
	},
	"../tmpl/third_party": {
		Filename: "third_party", Mode: 0o20000000775, ModTime: time.Unix(1609392014, 1609392014811860188), Compression: 0,
	},
	"../tmpl/third_party/database": {
		Filename: "database", Mode: 0o20000000775, ModTime: time.Unix(1609392168, 1609392168631506967), Compression: 0,
	},
	"../tmpl/third_party/database/database.go.tmpl": {
		Filename: "database.go.tmpl", Mode: 0o664, ModTime: time.Unix(1609392168, 1609392168631506967), Compression: 0,
		Content: []byte("package database\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/lib/pq\"\n\n\t\"{{ .ProjectName }}/configs\"\n)\n\nfunc New(cfg *configs.Configs) *sql.DB {\n\tdsn := fmt.Sprintf(\"%s://%s/%s?sslmode=%s&user=%s&password=%s\",\n\t\tcfg.Database.Driver,\n\t\tcfg.Database.Host,\n\t\tcfg.Database.Name,\n\t\tcfg.Database.SslMode,\n\t\tcfg.Database.User,\n\t\tcfg.Database.Pass,\n\t)\n\n\tdb, err := sql.Open(cfg.Database.Driver, dsn)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn db\n}\n\nfunc NewSqlx(cfg *configs.Configs) *sqlx.DB {\n\tdsn := fmt.Sprintf(\"%s://%s/%s?sslmode=%s&user=%s&password=%s\",\n\t\tcfg.Database.Driver,\n\t\tcfg.Database.Host,\n\t\tcfg.Database.Name,\n\t\tcfg.Database.SslMode,\n\t\tcfg.Database.User,\n\t\tcfg.Database.Pass,\n\t)\n\n\tdb, err := sqlx.Open(cfg.Database.Driver, dsn)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn db\n}\n"),
	},
}}
